{"version":3,"sources":["../../../node_modules/signal-exit/src/index.ts","../../../node_modules/signal-exit/src/signals.ts"],"sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nimport { signals } from './signals.js'\nexport { signals }\n\n// just a loosened process type so we can do some evil things\ntype ProcessRE = NodeJS.Process & {\n  reallyExit: (code?: number | undefined | null) => any\n  emit: (ev: string, ...a: any[]) => any\n}\n\nconst processOk = (process: any): process is ProcessRE =>\n  !!process &&\n  typeof process === 'object' &&\n  typeof process.removeListener === 'function' &&\n  typeof process.emit === 'function' &&\n  typeof process.reallyExit === 'function' &&\n  typeof process.listeners === 'function' &&\n  typeof process.kill === 'function' &&\n  typeof process.pid === 'number' &&\n  typeof process.on === 'function'\n\nconst kExitEmitter = Symbol.for('signal-exit emitter')\nconst global: typeof globalThis & { [kExitEmitter]?: Emitter } = globalThis\nconst ObjectDefineProperty = Object.defineProperty.bind(Object)\n\n/**\n * A function that takes an exit code and signal as arguments\n *\n * In the case of signal exits *only*, a return value of true\n * will indicate that the signal is being handled, and we should\n * not synthetically exit with the signal we received. Regardless\n * of the handler return value, the handler is unloaded when an\n * otherwise fatal signal is received, so you get exactly 1 shot\n * at it, unless you add another onExit handler at that point.\n *\n * In the case of numeric code exits, we may already have committed\n * to exiting the process, for example via a fatal exception or\n * unhandled promise rejection, so it is impossible to stop safely.\n */\nexport type Handler = (\n  code: number | null | undefined,\n  signal: NodeJS.Signals | null\n) => true | void\ntype ExitEvent = 'afterExit' | 'exit'\ntype Emitted = { [k in ExitEvent]: boolean }\ntype Listeners = { [k in ExitEvent]: Handler[] }\n\n// teeny special purpose ee\nclass Emitter {\n  emitted: Emitted = {\n    afterExit: false,\n    exit: false,\n  }\n\n  listeners: Listeners = {\n    afterExit: [],\n    exit: [],\n  }\n\n  count: number = 0\n  id: number = Math.random()\n\n  constructor() {\n    if (global[kExitEmitter]) {\n      return global[kExitEmitter]\n    }\n    ObjectDefineProperty(global, kExitEmitter, {\n      value: this,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    })\n  }\n\n  on(ev: ExitEvent, fn: Handler) {\n    this.listeners[ev].push(fn)\n  }\n\n  removeListener(ev: ExitEvent, fn: Handler) {\n    const list = this.listeners[ev]\n    const i = list.indexOf(fn)\n    /* c8 ignore start */\n    if (i === -1) {\n      return\n    }\n    /* c8 ignore stop */\n    if (i === 0 && list.length === 1) {\n      list.length = 0\n    } else {\n      list.splice(i, 1)\n    }\n  }\n\n  emit(\n    ev: ExitEvent,\n    code: number | null | undefined,\n    signal: NodeJS.Signals | null\n  ): boolean {\n    if (this.emitted[ev]) {\n      return false\n    }\n    this.emitted[ev] = true\n    let ret: boolean = false\n    for (const fn of this.listeners[ev]) {\n      ret = fn(code, signal) === true || ret\n    }\n    if (ev === 'exit') {\n      ret = this.emit('afterExit', code, signal) || ret\n    }\n    return ret\n  }\n}\n\nabstract class SignalExitBase {\n  abstract onExit(cb: Handler, opts?: { alwaysLast?: boolean }): () => void\n  abstract load(): void\n  abstract unload(): void\n}\n\nconst signalExitWrap = <T extends SignalExitBase>(handler: T) => {\n  return {\n    onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n      return handler.onExit(cb, opts)\n    },\n    load() {\n      return handler.load()\n    },\n    unload() {\n      return handler.unload()\n    },\n  }\n}\n\nclass SignalExitFallback extends SignalExitBase {\n  onExit() {\n    return () => {}\n  }\n  load() {}\n  unload() {}\n}\n\nclass SignalExit extends SignalExitBase {\n  // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n  // so use a supported signal instead\n  /* c8 ignore start */\n  #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP'\n  /* c8 ignore stop */\n  #emitter = new Emitter()\n  #process: ProcessRE\n  #originalProcessEmit: ProcessRE['emit']\n  #originalProcessReallyExit: ProcessRE['reallyExit']\n\n  #sigListeners: { [k in NodeJS.Signals]?: () => void } = {}\n  #loaded: boolean = false\n\n  constructor(process: ProcessRE) {\n    super()\n    this.#process = process\n    // { <signal>: <listener fn>, ... }\n    this.#sigListeners = {}\n    for (const sig of signals) {\n      this.#sigListeners[sig] = () => {\n        // If there are no other listeners, an exit is coming!\n        // Simplest way: remove us and then re-send the signal.\n        // We know that this will kill the process, so we can\n        // safely emit now.\n        const listeners = this.#process.listeners(sig)\n        let { count } = this.#emitter\n        // This is a workaround for the fact that signal-exit v3 and signal\n        // exit v4 are not aware of each other, and each will attempt to let\n        // the other handle it, so neither of them do. To correct this, we\n        // detect if we're the only handler *except* for previous versions\n        // of signal-exit, and increment by the count of listeners it has\n        // created.\n        /* c8 ignore start */\n        const p = process as unknown as {\n          __signal_exit_emitter__?: { count: number }\n        }\n        if (\n          typeof p.__signal_exit_emitter__ === 'object' &&\n          typeof p.__signal_exit_emitter__.count === 'number'\n        ) {\n          count += p.__signal_exit_emitter__.count\n        }\n        /* c8 ignore stop */\n        if (listeners.length === count) {\n          this.unload()\n          const ret = this.#emitter.emit('exit', null, sig)\n          /* c8 ignore start */\n          const s = sig === 'SIGHUP' ? this.#hupSig : sig\n          if (!ret) process.kill(process.pid, s)\n          /* c8 ignore stop */\n        }\n      }\n    }\n\n    this.#originalProcessReallyExit = process.reallyExit\n    this.#originalProcessEmit = process.emit\n  }\n\n  onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return () => {}\n    }\n    /* c8 ignore stop */\n\n    if (this.#loaded === false) {\n      this.load()\n    }\n\n    const ev = opts?.alwaysLast ? 'afterExit' : 'exit'\n    this.#emitter.on(ev, cb)\n    return () => {\n      this.#emitter.removeListener(ev, cb)\n      if (\n        this.#emitter.listeners['exit'].length === 0 &&\n        this.#emitter.listeners['afterExit'].length === 0\n      ) {\n        this.unload()\n      }\n    }\n  }\n\n  load() {\n    if (this.#loaded) {\n      return\n    }\n    this.#loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    this.#emitter.count += 1\n\n    for (const sig of signals) {\n      try {\n        const fn = this.#sigListeners[sig]\n        if (fn) this.#process.on(sig, fn)\n      } catch (_) {}\n    }\n\n    this.#process.emit = (ev: string, ...a: any[]) => {\n      return this.#processEmit(ev, ...a)\n    }\n    this.#process.reallyExit = (code?: number | null | undefined) => {\n      return this.#processReallyExit(code)\n    }\n  }\n\n  unload() {\n    if (!this.#loaded) {\n      return\n    }\n    this.#loaded = false\n\n    signals.forEach(sig => {\n      const listener = this.#sigListeners[sig]\n      /* c8 ignore start */\n      if (!listener) {\n        throw new Error('Listener not defined for signal: ' + sig)\n      }\n      /* c8 ignore stop */\n      try {\n        this.#process.removeListener(sig, listener)\n        /* c8 ignore start */\n      } catch (_) {}\n      /* c8 ignore stop */\n    })\n    this.#process.emit = this.#originalProcessEmit\n    this.#process.reallyExit = this.#originalProcessReallyExit\n    this.#emitter.count -= 1\n  }\n\n  #processReallyExit(code?: number | null | undefined) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return 0\n    }\n    this.#process.exitCode = code || 0\n    /* c8 ignore stop */\n\n    this.#emitter.emit('exit', this.#process.exitCode, null)\n    return this.#originalProcessReallyExit.call(\n      this.#process,\n      this.#process.exitCode\n    )\n  }\n\n  #processEmit(ev: string, ...args: any[]): any {\n    const og = this.#originalProcessEmit\n    if (ev === 'exit' && processOk(this.#process)) {\n      if (typeof args[0] === 'number') {\n        this.#process.exitCode = args[0]\n        /* c8 ignore start */\n      }\n      /* c8 ignore start */\n      const ret = og.call(this.#process, ev, ...args)\n      /* c8 ignore start */\n      this.#emitter.emit('exit', this.#process.exitCode, null)\n      /* c8 ignore stop */\n      return ret\n    } else {\n      return og.call(this.#process, ev, ...args)\n    }\n  }\n}\n\nconst process = globalThis.process\n// wrap so that we call the method on the actual handler, without\n// exporting it directly.\nexport const {\n  /**\n   * Called when the process is exiting, whether via signal, explicit\n   * exit, or running out of stuff to do.\n   *\n   * If the global process object is not suitable for instrumentation,\n   * then this will be a no-op.\n   *\n   * Returns a function that may be used to unload signal-exit.\n   */\n  onExit,\n\n  /**\n   * Load the listeners.  Likely you never need to call this, unless\n   * doing a rather deep integration with signal-exit functionality.\n   * Mostly exposed for the benefit of testing.\n   *\n   * @internal\n   */\n  load,\n\n  /**\n   * Unload the listeners.  Likely you never need to call this, unless\n   * doing a rather deep integration with signal-exit functionality.\n   * Mostly exposed for the benefit of testing.\n   *\n   * @internal\n   */\n  unload,\n} = signalExitWrap(\n  processOk(process) ? new SignalExit(process) : new SignalExitFallback()\n)\n","/**\n * This is not the set of all possible signals.\n *\n * It IS, however, the set of all signals that trigger\n * an exit on either Linux or BSD systems.  Linux is a\n * superset of the signal names supported on BSD, and\n * the unknown signals just fail to register, so we can\n * catch that easily enough.\n *\n * Windows signals are a different set, since there are\n * signals that terminate Windows processes, but don't\n * terminate (or don't even exist) on Posix systems.\n *\n * Don't bother with SIGKILL.  It's uncatchable, which\n * means that we can't fire any callbacks anyway.\n *\n * If a user does happen to register a handler on a non-\n * fatal signal like SIGWINCH or something, and then\n * exit, it'll end up firing `process.emit('exit')`, so\n * the handler will be fired anyway.\n *\n * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n * artificially, inherently leave the process in a\n * state from which it is not safe to try and enter JS\n * listeners.\n */\nexport const signals: NodeJS.Signals[] = []\nsignals.push('SIGHUP', 'SIGINT', 'SIGTERM')\n\nif (process.platform !== 'win32') {\n  signals.push(\n    'SIGALRM',\n    'SIGABRT',\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT')\n}\n"],"mappings":"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","names":["process"]}